# Финальное исправление - Правильная работа с apiClient

## Проблема
Ошибка `TypeError: (data.data || []).map is not a function` возникала из-за неправильного понимания того, что возвращает `apiClient`.

## Корень проблемы

### Как работает axios
```typescript
// axios возвращает объект response:
{
  data: { ... },      // <-- Данные от сервера
  status: 200,
  statusText: 'OK',
  headers: { ... },
  config: { ... }
}
```

### Что возвращает apiClient
`apiClient` - это axios instance, который возвращает **полный axios response**, а не только данные.

Response interceptor в `api.ts` возвращает `response`, а не `response.data`:
```typescript
apiClient.interceptors.response.use(
  (response: any) => {
    // ...
    return response;  // <-- Возвращает полный response!
  }
);
```

## Правильное использование

### ❌ Неправильно (было):
```typescript
const data: ApiResponse = await apiClient.get('/api/blog-posts');
const posts = data.data.map(...);  // Ошибка! data - это axios response
```

### ✅ Правильно (стало):
```typescript
const response = await apiClient.get('/api/blog-posts');
const apiResponse: ApiResponse = response.data;  // Распаковываем данные
const posts: BlogPost[] = apiResponse.data || [];  // Получаем массив
```

## Структура данных

```
apiClient.get('/api/blog-posts')
  ↓
axios response {
  data: {                    ← response.data (Laravel API response)
    status: "success",
    data: [...]              ← response.data.data (массив постов)
  },
  status: 200,
  headers: {...}
}
```

## Исправленные файлы

### 1. `frontend_next/src/app/admin/blog/page.tsx`
- ✅ `getData()` - правильная распаковка response.data.data
- ✅ `getGlobalSEOSettings()` - response.data?.data
- ✅ `handleSEOImageUpload()` - response.data
- ✅ `handleSubmit()` - response.data

### 2. `frontend_next/src/app/admin/blog/columns.tsx`
- ✅ `fetchGlobalSEOSettings()` - response.data?.data
- ✅ `handleSEOImageUpload()` - response.data
- ✅ `handleSubmit()` в EditCell - response.data
- ✅ `handleDelete()` - response.data
- ✅ `handleSave()` в SortOrderCell - response.data
- ✅ `handleStatusChange()` - response.data

### 3. `frontend_next/src/app/admin/blog/[slug]/page.tsx`
- ✅ `handleSubmit()` в EditBlockDialog - response.data
- ✅ `handleDelete()` в DeleteBlockDialog - response.data
- ✅ `fetchPost()` - response.data
- ✅ `handleCreateBlock()` - response.data

## Паттерн использования

Для всех вызовов apiClient используем единый паттерн:

```typescript
// GET запрос
const response = await apiClient.get('/api/endpoint');
const data = response.data;  // Laravel API response

// POST запрос
const response = await apiClient.post('/api/endpoint', formData);
const result = response.data;  // Laravel API response

// PUT запрос
const response = await apiClient.put('/api/endpoint', data);
const result = response.data;  // Laravel API response

// DELETE запрос
const response = await apiClient.delete('/api/endpoint');
const result = response.data;  // Laravel API response

// PATCH запрос
const response = await apiClient.patch('/api/endpoint', data);
const result = response.data;  // Laravel API response
```

## Почему это работает

1. `apiClient.get()` возвращает axios response
2. `response.data` содержит данные от Laravel API
3. Laravel API возвращает `{ status: "success", data: [...] }`
4. Поэтому `response.data.data` - это наш массив постов

## Тестирование

После исправления:
1. Перезапустите dev server
2. Откройте `http://localhost:3000/admin/blog`
3. Список статей должен загрузиться без ошибок
4. Все CRUD операции должны работать

## Итог

Теперь код правильно работает с axios response и корректно извлекает данные из Laravel API.
